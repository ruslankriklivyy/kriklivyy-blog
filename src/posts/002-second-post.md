---
title: React + Mobx в чём смысл?
date: 23 June 2021
descr: Сегодня я хочу рассказать вам о том, как на нашем проекте состоялся переход на Mobx, какие преимущества это даёт.
url: /react-and-mobx
poster: "https://web-creator.ru/uploads/Page/17/mobx.svg"
---

<img src="https://habrastorage.org/r/w1560/webt/lv/he/d2/lvhed2wb-qbln7ffhw3_e9ljj0e.png" alt="post img" />

Почему вообще надо на что-то переходить? На самом деле, ответ на этот вопрос — уже половина дела. Многие сейчас любят применять новые технологии только потому, что они новые. Хорошая строчка в резюме, возможность саморазвития, быть в тренде. Здорово, когда можно просто идти вперёд.
<br/>
<br/>
И всё же, каждый инструмент должен решать свои задачи, и от них мы так или иначе отталкиваемся, когда пишем коммерческий код.
<br/>
<br/>
У нас в проекте существует некоторое количество виджетов, куда пользователь вводит свои данные, взаимодействует с формами. Как правило, в каждом виджете несколько экранов. Когда-то давно это всё работало на старом добром шаблонизаторе MarkoJS + обязательный jQuery на клиенте. Взаимодействие с формами писалось в императивном стиле, if… else, коллбэки и вот это всё самое то, что уже, кажется, осталось в прошлом.
<br/>
<br/>
Потом настало время <b>React</b>. Бизнес-логика на клиенте всё утолщалась, вариантов взаимодействий становилось много, императивный код превращался в сложно устроенную кашу. Декларативный react-код оказался гораздо удобнее. Можно было, наконец, сконцентрироваться на логике, а не представлении, переиспользовать компоненты и легко распределять задачи по разработке новых фич между разными сотрудниками.
<br/>
<br/>
У нас, если судить по количеству статей и упоминаниям в вакансиях, наиболее известен Redux. Собственно, я уже занёс руку, чтобы инсталлировать его в наш проект и начать разработку, как в самый последний момент (и это буквально!) чёрт дёрнул полистать Хабр, а тут как-раз шло обсуждение темы «Redux или Mobx?» Вот эта статья: <a href="habr.com/ru/post/459706" >habr.com/ru/post/459706</a>. Прочитав её, а также все комментарии под ней, я понял, что всё-таки буду использовать Mobx.
<br/>
<br/>

<h3>О приложении</h3>
Нам требуется на фронте построить некий конструктор экранов и форм, которые потом можно было бы быстро тасовать, соединять друг с другом вслед за меняющимися требованиями бизнеса. Это неизбежно подвигает нас к следующему: создать коллекцию абсолютно изолированных компонентов, а также некий основной компонент, соответствующий каждому из наших виджетов (по сути это отдельные SPA, создаваемые каждый раз под новый бизнес-кейс в общем приложении).
<br/>
<br/>
В примерах будет показана урезанная версия одного из таких мини-приложений. Чтобы не громоздить лишний код, пусть это будет форма из трёх полей ввода и кнопки.

<h3>Данные</h3>

<b>Mobx</b> по сути не является фреймворком, это всего лишь библиотека. В руководстве прямо сказано, что она не организует ваши данные напрямую. Вы сами должны придумать такую организацию. Кстати, мы используем Mobx 4, потому что версия 5 использует тип данных Sybmol, который, к сожалению, поддерживается не всеми браузерами.

<h3>Управление</h3>

Хорошо, у нас полностью автономные компоненты View-Store, но как у нас всё это срастается в целое приложение? Для отображения у нас будет корневой компонент App.js, а для управления потоками данных основное хранилище mainStore.js. Принцип простой: mainStore знает всё обо всех хранилищах всех нужных компонентов (ниже будет показано, как это достигается). Другие хранилища ничего не знают об окружающем мире вообще (ну, будет одно исключение — словари). Таким образом, мы гарантированно знаем, куда идут наши данные и где их перехватывать.
<br/>
<br/>
Начнём писать код. Основной файл приложения index.js:

```javascript
import React from "react"
import ReactDOM from "react-dom"
import { Provider } from "mobx-react"
import App from "./components/App"
import mainStore from "./stores/mainStore"
import optionsStore from "./stores/optionsStore"
// для IE11
require("es6-object-assign").polyfill()
require("./static/less/main.less")

const stores = {
  mainStore,
  optionsStore,
  ButtonStore: mainStore.ButtonStore,
  FioStore: mainStore.FioStore,
  EmailStore: mainStore.EmailStore,
}

ReactDOM.render(
  <Provider {...stores}>
    <App />
  </Provider>,
  document.getElementById("reactContainer")
)
```

Здесь видна основная концепция Mobx. Данные (stores) доступны в любом месте приложения через механизм <b>Provider</b>. Мы оборачиваем наше приложение, перечисляя необходимые в работе хранилища. Для использования Provider подключаем модуль mobx-react. Для того, чтобы основное управляющее хранилище mainStore со старта имело доступ ко всем остальным данным, делаем инициализацию дочерних хранилищ внутри mainStore:

```javascript
// mainStore.js

import optionsStore from "./optionsStore";
import ButtonStore from "./ButtonStore";
import FioStore from "./FioStore";
import EmailStore from "./EmailStore";
....

class mainStore {
    constructor() {
        /**
         * Инициализация дочерних хранилищ
         */
        this.ButtonStore = new ButtonStore();
        this.FioStore = new FioStore();
        this.EmailStore = new EmailStore();

    ...
```

Теперь App.js, скелет нашего приложения

```javascript
import React from "react"
import { observer, inject } from "mobx-react"
import ButtonArea from "./ButtonArea"
import Email from "./Email"
import Fio from "./Fio"
import l10n from "../../../l10n/localization.js"

@inject("mainStore")
@observer
export default class App extends React.Component {
  constructor(props) {
    super(props)
  }

  render() {
    const mainStore = this.props.mainStore

    return (
      <div className="container">
        <Fio
          label={l10n.ru.profile.name}
          name={"name"}
          value={mainStore.userData.name}
          daData={true}
        />
        <Fio
          label={l10n.ru.profile.surname}
          name={"surname"}
          value={mainStore.userData.surname}
          daData={true}
        />
        <Email
          label={l10n.ru.profile.email}
          name={"email"}
          value={mainStore.userData.email}
        />
        <ButtonArea />
      </div>
    )
  }
}
```

Тут ещё две основные концепции Mobx – inject и observer.
<b>inject</b> внедряет только необходимый store в приложении. Разные части нашего приложения используют разные хранилища, которые мы перечисляем в inject через запятую. Естественно, подключаемые хранилища должны быть изначально перечислены в Provider. Хранилища доступны в компоненте через this.props.yourStoreName.
<b>observer</b> – декоратор указывает, что наш компонент будет подписан на данные, которые изменяются с помощью Mobx. Данные изменились – в компоненте возникла реакция (ниже будет показано, как). Таким образом, никаких специальных подписок и коллбэков – Mobx доставляет изменения сам!

<img src="https://media.giphy.com/media/MT5UUV1d4CXE2A37Dg/giphy.gif" alt="post gif" />
